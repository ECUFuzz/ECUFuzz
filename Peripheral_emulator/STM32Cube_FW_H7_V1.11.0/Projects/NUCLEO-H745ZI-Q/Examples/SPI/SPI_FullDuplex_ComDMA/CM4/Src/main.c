#include "main.h"
#include <string.h>

#define HSEM_ID_0 (0U) /* HW semaphore 0*/

#define TX_BUFFER_SIZE1 16
#define TX_BUFFER_SIZE2 28
#define NUM_SEQUENCES1 61
#define NUM_SEQUENCES2 36

// Define the shared memory region in SRAM4
#define SHARED_MEMORY_ADDRESS 0x38000000
#define SHARED_MEMORY_SIZE (TX_BUFFER_SIZE1 * NUM_SEQUENCES1 + TX_BUFFER_SIZE2 * NUM_SEQUENCES2)

#define FLASH_SECTOR_SIZE 0x20000  // 128KB sector
#define FLASH_START_ADDR FLASH_BANK2_BASE

static uint8_t isModified1 = 0;
static uint8_t isModified2 = 0;
static uint8_t originalLastRow1[TX_BUFFER_SIZE1];
static uint8_t originalLastRow2[TX_BUFFER_SIZE2];
static uint32_t modificationStartTime = 0;
static uint32_t modificationDuration = 0;
static uint32_t modificationDuration1 = 0;
static uint32_t modificationDuration2 = 0;
// Define the shared memory structure
#define MAX_SEQUENCES 100  // Choose a reasonable maximum

// Modify the SharedMemory_TypeDef structure
typedef struct {
    uint8_t aTxBuffers1[MAX_SEQUENCES][TX_BUFFER_SIZE1];
    uint8_t aTxBuffers2[MAX_SEQUENCES][TX_BUFFER_SIZE2];
    uint32_t sequenceRepeatCounts1[MAX_SEQUENCES];
    uint32_t sequenceRepeatCounts2[MAX_SEQUENCES];
    uint32_t actualNumSequences1;
    uint32_t actualNumSequences2;
    volatile uint32_t flag;
} SharedMemory_TypeDef;
// Global variables to store the actual number of sequences
static uint32_t actualNumSequences1 = 0;
static uint32_t actualNumSequences2 = 0;

// Define the shared memory pointer
#define SHARED_MEMORY ((SharedMemory_TypeDef*)SHARED_MEMORY_ADDRESS)

volatile uint32_t Notif_Recieved;
static void Error_Handler(void);
static void FDCAN_Config(void);

uint8_t aTxBuffers1[NUM_SEQUENCES1][TX_BUFFER_SIZE1] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 Unknown WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0C, 0xA8, 0x00, 0x00, 0x0C, 0xA8, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1300 Unknown WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //1 WR_SOFT_RESET WR_SOFT_RESET WR_MODE WR_MODE
{0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //10 WR_MODE WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x00, 0x1B, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_MONITOR_I_DATA RD_MONITOR_II_DATA WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 WR_CONFIG_1 WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 WR_CONFIG_1 WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_SID WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x02, 0x1F, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_SID WR_MODE WR_MODE WR_MODE
{0x28, 0x06, 0x07, 0x6F, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_DEVICE_ID WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x02, 0x09, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_REVISION_ID WR_MODE WR_MODE WR_MODE
{0x28, 0x07, 0x84, 0x5E, 0x28, 0x07, 0xD2, 0x49, 0x28, 0x0A, 0x0C, 0x8D, 0x28, 0x02, 0xE0, 0x89}, //1 RD_SERIAL1 RD_SERIAL2 RD_SERIAL3 WR_MODE
{0x28, 0x05, 0x34, 0x3F, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x05, 0x7A, 0xA8, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x05, 0xC1, 0x29, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x06, 0x07, 0x9A, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x06, 0x4E, 0x08, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x06, 0x94, 0x7A, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x06, 0xDA, 0xED, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x07, 0x21, 0x69, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x07, 0x67, 0xEE, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x07, 0xAE, 0x4F, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x07, 0xF4, 0xBE, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x08, 0x3B, 0x39, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x08, 0x81, 0xAC, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x08, 0xC8, 0x19, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x09, 0x0E, 0x8E, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x09, 0x54, 0xFE, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x09, 0x9B, 0x69, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x09, 0xE2, 0x2B, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x0A, 0x28, 0x59, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x0A, 0x6E, 0xC8, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x0A, 0xB5, 0x39, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89}, //1 RD_CLOCK_COUNTER WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x02, 0xE0, 0x89, 0x28, 0x00, 0x00, 0x0D}, //1 WR_OFFSET_CANCELLATION WR_MODE WR_MODE WR_OFFSET_CANCELLATION
{0x2A, 0x10, 0x04, 0x0D, 0x2A, 0x1F, 0xFD, 0x8F, 0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x10, 0x1C}, //192 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x28, 0x03, 0xCC, 0x49, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //1 RD_SELF_TEST_CH1 WR_MODE WR_MODE WR_MODE
{0x28, 0x03, 0xDC, 0x4E, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //2 RD_SELF-TEST_CH2 WR_MODE WR_MODE WR_MODE
{0x2A, 0x1F, 0xFE, 0x4D, 0x2A, 0x1F, 0xFE, 0x08, 0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x00, 0x1B}, //1 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //10 WR_MODE WR_MODE WR_MODE WR_MODE
{0x2A, 0x10, 0x01, 0x0C, 0x2A, 0x1F, 0xFD, 0x4B, 0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x00, 0x1B}, //64 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //10 WR_MODE WR_MODE WR_MODE WR_MODE
{0x6A, 0x11, 0xE4, 0x0F, 0x6A, 0x1E, 0x1C, 0x4B, 0x68, 0x00, 0xC0, 0x0E, 0x68, 0x00, 0x00, 0x1B}, //64 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x68, 0x00, 0x00, 0x0D, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x6A, 0x11, 0xEA, 0x0E, 0x6A, 0x1E, 0x21, 0x0B, 0x68, 0x00, 0xC0, 0x0E, 0x68, 0x00, 0x00, 0x1B}, //1 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //4 WR_MODE WR_MODE WR_MODE WR_MODE
{0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //6 WR_MODE WR_MODE WR_MODE WR_MODE
{0x2A, 0x1F, 0xFF, 0x8B, 0x2A, 0x1F, 0xFE, 0x4D, 0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x00, 0x1B}, //64 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //10 WR_MODE WR_MODE WR_MODE WR_MODE
{0x6A, 0x1E, 0x20, 0x88, 0x6A, 0x11, 0xE3, 0xCE, 0x68, 0x00, 0xC0, 0x0E, 0x68, 0x00, 0x00, 0x1B}, //64 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x68, 0x00, 0x00, 0x0D, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //1 WR_TEST_MODE WR_MODE WR_MODE WR_MODE
{0x6A, 0x1E, 0x33, 0xCC, 0x6A, 0x11, 0xCB, 0x4C, 0x68, 0x00, 0xC0, 0x0E, 0x68, 0x00, 0x00, 0x1B}, //1 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89, 0x68, 0x0C, 0x60, 0x89}, //4 WR_MODE WR_MODE WR_MODE WR_MODE
{0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89, 0x28, 0x0C, 0x60, 0x89}, //6 WR_MODE WR_MODE WR_MODE WR_MODE
{0x2A, 0x10, 0x00, 0x8F, 0x2A, 0x1F, 0xFD, 0xCA, 0x28, 0x00, 0xC0, 0x0E, 0x28, 0x00, 0x00, 0x1B}, //65 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
{0x28, 0x00, 0x00, 0x0D, 0x28, 0x00, 0x1A, 0xDA, 0x28, 0x0F, 0xF0, 0x8B, 0x28, 0x0F, 0xF0, 0x8B}, //1 WR_OFFSET_CANCELLATION WR_OFFSET_CANCELLATION WR_MODE WR_MODE
{0x28, 0x00, 0x00, 0x0D, 0x00, 0x0F, 0xF0, 0x80, 0x00, 0x0F, 0xF0, 0x80, 0x00, 0x0F, 0xF0, 0x80}, //1 WR_END_OF_PROG WR_MODE WR_MODE WR_MODE
{0x02, 0x10, 0x01, 0x42, 0x02, 0x1F, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06}, //1840 RD_SENSOR_DATA_CH1 RD_SENSOR_DATA_CH2 RD_MONITOR_I_DATA RD_MONITOR_II_DATA
};

uint8_t aTxBuffers2[NUM_SEQUENCES2][TX_BUFFER_SIZE2] = {
{0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04}, //2003 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x03, 0xF0, 0x00, 0x0A, 0x03, 0xF0, 0x00, 0x0A, 0x03, 0xF0, 0x00, 0x0A, 0x03, 0xF0, 0x00, 0x0A, 0x03, 0xF0, 0x00, 0x0A, 0x03, 0xF8, 0x00, 0x06, 0x00, 0x40, 0x00, 0x04}, //100 YRS1_LF(wx) YRS2_LF(wz) ACC1_LF(y) ACC2_LF(x) ACC3_LF(z) Cluster_Flags Module_Address
{0x00, 0x40, 0x00, 0x04, 0x00, 0x48, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, //100 YRS1_LF(wx) YRS2_LF(wz) ACC1_LF(y) ACC2_LF(x) ACC3_LF(z) Cluster_Flags Module_Address
{0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x08, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x0F, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x12, 0x00, 0x40, 0xC8, 0x17, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x08, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xC8, 0x15, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x19, 0x08, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x23, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x08, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x00, 0x28, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x35, 0x80, 0x47, 0x9C, 0xF0, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x08, 0x40, 0x06, 0x61, 0x00, 0x00, 0x00, 0x37, 0x00, 0x07, 0x9C, 0xF2, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x01, 0xC2, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x63, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Broadcast Module_Broadcast Module_Broadcast Module_Broadcast Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x18, 0xCA, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x04, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x00, 0x0F, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x62, 0x34, 0x07, 0x00, 0x62, 0x63, 0x93, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x61, 0xA9, 0x5A, 0x00, 0x62, 0x63, 0x93, 0x80, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x62, 0x63, 0x93, 0x00, 0x63, 0x80, 0xC4, 0x00, 0x64, 0x09, 0x2B, 0x00, 0x62, 0x63, 0x93, 0x08, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x60, 0xE0, 0x03, 0x00, 0x65, 0x80, 0x6C, 0x08, 0x61, 0xA9, 0x5A, 0x00, 0x62, 0x63, 0x93, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x02, 0x00, 0x33, 0xFA, 0x02, 0x00, 0x01, 0x9E, 0x02, 0x0F, 0xCC, 0xFE, 0x02, 0x00, 0x00, 0xCF, 0x02, 0x0F, 0x64, 0x59, 0x02, 0x00, 0x00, 0x31, 0x00, 0x40, 0x06, 0x61}, //704 YRS1_LF(wx) YRS2_LF(wz) ACC1_LF(y) ACC2_LF(x) ACC3_LF(z) Cluster_Flags Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x6F, 0xFE, 0x46, 0x00, 0x6F, 0xFE, 0x82, 0x08, 0x6F, 0x7F, 0x82, 0x00, 0x68, 0x0D, 0xE6, 0x00, 0x68, 0x42, 0xDE, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x68, 0x00, 0x33, 0x00, 0x6F, 0xFF, 0x96, 0x00, 0x68, 0x4D, 0x23, 0x00, 0x68, 0xD6, 0x63, 0x08, 0x68, 0x42, 0xDE, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x08, 0x40, 0x06, 0x61, 0x00, 0x68, 0x42, 0xDE, 0x00, 0x6F, 0xBB, 0xB3, 0x00, 0x68, 0x42, 0xDE, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x08, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x68, 0x42, 0x5F, 0x08, 0x6F, 0xBB, 0x9F, 0x00, 0x68, 0x42, 0xDE, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x00, 0x40, 0x06, 0x61, 0x00, 0x68, 0x4D, 0x23, 0x00, 0x6F, 0xCB, 0x0B, 0x08, 0x68, 0x42, 0xDE, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61, 0x00, 0x40, 0x06, 0x61}, //2 Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address Module_Address
{0x02, 0x0F, 0xFB, 0xEF, 0x02, 0x0F, 0xFF, 0x8E, 0x02, 0x0F, 0xFA, 0x5D, 0x02, 0x0F, 0xF7, 0xB9, 0x02, 0x01, 0x37, 0x1E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06, 0x61}, //790 YRS1_LF(wx) YRS2_LF(wz) ACC1_LF(y) ACC2_LF(x) ACC3_LF(z) Cluster_Flags Module_Address
};
// Sequence repeat counts for SPI1 (existing array)
const uint32_t sequenceRepeatCounts1[NUM_SEQUENCES1] = {1, 1300, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 192, 1, 2, 1, 10, 64, 1, 1, 10, 64, 1, 1, 4, 6, 64, 1, 1, 10, 64, 1, 1, 4, 6, 65, 1, 1, 1};

// New sequence repeat counts for SPI2
const uint32_t sequenceRepeatCounts2[NUM_SEQUENCES2] = {2003, 100, 2, 100, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 704, 2, 2, 2, 2, 2, 1};

volatile uint32_t Notif_Recieved;

static void Error_Handler(void);

// If SpiHandle4 is needed elsewhere, keep this line; otherwise, it can be removed
extern SPI_HandleTypeDef SpiHandle4;
FDCAN_HandleTypeDef hfdcan;
FDCAN_RxHeaderTypeDef RxHeader;
uint8_t RxData[8];
FDCAN_TxHeaderTypeDef TxHeader;
uint8_t TxData[8] = {0x10, 0x32, 0x54, 0x76, 0x98, 0x00, 0x11, 0x22};;
static uint32_t BufferCmp8b(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength);
static uint32_t PerformCANTransmission(void);
static void LoadDataFromFlash(void);
static HAL_StatusTypeDef SaveModifiedDataToFlash(void);
static void PollCANMessages(void);
static void ProcessMainData(uint8_t* data, uint32_t length);
static void ProcessLastTwoRows(uint8_t* data, uint32_t length);
static void CheckAndResetModifications(void);
static HAL_StatusTypeDef SendCANAcknowledgment(uint8_t seq);

int main(void)
{
    /*HW semaphore Clock enable*/
    __HAL_RCC_HSEM_CLK_ENABLE();

    /* Activate HSEM notification for Cortex-M4*/
    HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));

    HAL_PWREx_ClearPendingEvent();
    HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);

    /* Clear HSEM flag */
    __HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));

    HAL_Init();

    // Enable D3 domain SRAM1 clock in sleep mode
    __HAL_RCC_D3SRAM1_CLK_SLEEP_ENABLE();

    /* Configure LED1, LED2, and LED3 */
    BSP_LED_Init(LED1);
    BSP_LED_Init(LED2);
    BSP_LED_Init(LED3);

    // Initialize user button
    BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);

    FDCAN_Config();

    // Initialize shared memory
    memset((void*)SHARED_MEMORY, 0, sizeof(SharedMemory_TypeDef));
    memcpy(SHARED_MEMORY->aTxBuffers1, aTxBuffers1, sizeof(aTxBuffers1));
    memcpy(SHARED_MEMORY->aTxBuffers2, aTxBuffers2, sizeof(aTxBuffers2));

    memcpy(SHARED_MEMORY->sequenceRepeatCounts1, sequenceRepeatCounts1, sizeof(sequenceRepeatCounts1));
    memcpy(SHARED_MEMORY->sequenceRepeatCounts2, sequenceRepeatCounts2, sizeof(sequenceRepeatCounts2));    
    // Store original last rows
    memcpy(originalLastRow1, SHARED_MEMORY->aTxBuffers1[NUM_SEQUENCES1 - 1], TX_BUFFER_SIZE1);
    memcpy(originalLastRow2, SHARED_MEMORY->aTxBuffers2[NUM_SEQUENCES2 - 1], TX_BUFFER_SIZE2);

    SHARED_MEMORY->flag = 0;
    LoadDataFromFlash();

    /* Infinite loop */
    while (1)
    {
        // Check and reset modifications if needed
        CheckAndResetModifications();

        // Check if the other core has processed the data
        if (SHARED_MEMORY->flag == 1)
        {
            // The other core has processed the data
            BSP_LED_Toggle(LED2);
            SHARED_MEMORY->flag = 0;  // Reset the flag
        }

        // Poll for new CAN messages
        PollCANMessages();
    }
}

static void Error_Handler(void)
{
    /* Turn LED3 on */
    BSP_LED_On(LED3);
    while(1)
    {
    }
}


#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{
    /* User can add his own implementation to report the file name and line number,
       ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

    /* Infinite loop */
    while (1)
    {
    }
}
#endif

void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
    Notif_Recieved = 1;
}

static void FDCAN_Config(void)
{
  FDCAN_FilterTypeDef sFilterConfig;
  hfdcan.Instance = FDCAN2;
  hfdcan.Init.FrameFormat = FDCAN_FRAME_CLASSIC;
  hfdcan.Init.Mode = FDCAN_MODE_NORMAL; //FDCAN_MODE_NORMAL FDCAN_MODE_EXTERNAL_LOOPBACK
  hfdcan.Init.AutoRetransmission = ENABLE;
  hfdcan.Init.TransmitPause = DISABLE;
  hfdcan.Init.ProtocolException = ENABLE;
  hfdcan.Init.NominalPrescaler = 0x5; /* tq = NominalPrescaler x (1/fdcan_ker_ck) */
  hfdcan.Init.NominalSyncJumpWidth = 0x2;
  hfdcan.Init.NominalTimeSeg1 = 0x5; /* NominalTimeSeg1 = Propagation_segment + Phase_segment_1 */
  hfdcan.Init.NominalTimeSeg2 = 0x2;
  hfdcan.Init.MessageRAMOffset = 0;
  hfdcan.Init.StdFiltersNbr = 1;
  hfdcan.Init.ExtFiltersNbr = 0;
  hfdcan.Init.RxFifo0ElmtsNbr = 1;
  hfdcan.Init.RxFifo0ElmtSize = FDCAN_DATA_BYTES_8;
  hfdcan.Init.RxFifo1ElmtsNbr = 1;
  hfdcan.Init.RxFifo1ElmtSize = FDCAN_DATA_BYTES_8;
  hfdcan.Init.RxBuffersNbr = 8;
  hfdcan.Init.TxEventsNbr = 1;
  hfdcan.Init.TxBuffersNbr = 0;
  hfdcan.Init.TxFifoQueueElmtsNbr = 1;
  hfdcan.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
  hfdcan.Init.TxElmtSize = FDCAN_DATA_BYTES_8;
  if (HAL_FDCAN_Init(&hfdcan) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }

  /* Configure Rx filter */
  sFilterConfig.IdType = FDCAN_STANDARD_ID;
  sFilterConfig.FilterIndex = 0;
  sFilterConfig.FilterType = FDCAN_FILTER_MASK;
  sFilterConfig.FilterConfig = FDCAN_FILTER_TO_RXFIFO0;
  sFilterConfig.FilterID1 = 0x321;
  sFilterConfig.FilterID2 = 0x7FF;
  if (HAL_FDCAN_ConfigFilter(&hfdcan, &sFilterConfig) != HAL_OK)
  {
    /* Filter configuration Error */
    Error_Handler();
  }

  /* Prepare Tx Header */
  TxHeader.Identifier = 0x111;
  TxHeader.IdType = FDCAN_STANDARD_ID;
  TxHeader.TxFrameType = FDCAN_DATA_FRAME;
  TxHeader.DataLength = FDCAN_DLC_BYTES_8;
  TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
  TxHeader.BitRateSwitch = FDCAN_BRS_OFF;
  TxHeader.FDFormat = FDCAN_CLASSIC_CAN;
  TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
  TxHeader.MessageMarker = 0x52;

  /* Start the FDCAN module */
  if (HAL_FDCAN_Start(&hfdcan) != HAL_OK)
  {
    /* Start Error */
    Error_Handler();
  }
  // HAL_FDCAN_ActivateNotification(&hfdcan, FDCAN_IT_RX_FIFO0_NEW_MESSAGE, 0);
}

static void ProcessMainData(uint8_t* data, uint32_t length)
{
    if (length < 2 * sizeof(uint32_t))
    {
        // Error: Insufficient data size
        return;
    }

    uint32_t offset = 0;

    // Get the actual number of sequences
    memcpy(&SHARED_MEMORY->actualNumSequences1, data + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);
    memcpy(&SHARED_MEMORY->actualNumSequences2, data + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);

    // Ensure we don't exceed the maximum
    if (SHARED_MEMORY->actualNumSequences1 > MAX_SEQUENCES || 
        SHARED_MEMORY->actualNumSequences2 > MAX_SEQUENCES)
    {
        // Error: Too many sequences
        return;
    }

    // Calculate expected data size
    uint32_t expectedSize = 2 * sizeof(uint32_t) +
        (SHARED_MEMORY->actualNumSequences1 * TX_BUFFER_SIZE1) +
        (SHARED_MEMORY->actualNumSequences2 * TX_BUFFER_SIZE2) +
        (SHARED_MEMORY->actualNumSequences1 * sizeof(uint32_t)) +
        (SHARED_MEMORY->actualNumSequences2 * sizeof(uint32_t));

    if (length != expectedSize)
    {
        // Error: Incorrect data size
        return;
    }

    // Copy aTxBuffers1
    memcpy(SHARED_MEMORY->aTxBuffers1, data + offset, 
           SHARED_MEMORY->actualNumSequences1 * TX_BUFFER_SIZE1);
    offset += SHARED_MEMORY->actualNumSequences1 * TX_BUFFER_SIZE1;

    // Copy aTxBuffers2
    memcpy(SHARED_MEMORY->aTxBuffers2, data + offset, 
           SHARED_MEMORY->actualNumSequences2 * TX_BUFFER_SIZE2);
    offset += SHARED_MEMORY->actualNumSequences2 * TX_BUFFER_SIZE2;

    // Copy sequenceRepeatCounts1
    memcpy(SHARED_MEMORY->sequenceRepeatCounts1, data + offset, 
           SHARED_MEMORY->actualNumSequences1 * sizeof(uint32_t));
    offset += SHARED_MEMORY->actualNumSequences1 * sizeof(uint32_t);

    // Copy sequenceRepeatCounts2
    memcpy(SHARED_MEMORY->sequenceRepeatCounts2, data + offset, 
           SHARED_MEMORY->actualNumSequences2 * sizeof(uint32_t));

    // Update global variables
    actualNumSequences1 = SHARED_MEMORY->actualNumSequences1;
    actualNumSequences2 = SHARED_MEMORY->actualNumSequences2;

    // Set flag to indicate new data is available
    SHARED_MEMORY->flag = 1;

    // Save the modified data to Flash
    HAL_StatusTypeDef flashStatus = SaveModifiedDataToFlash();
    if (flashStatus != HAL_OK)
    {
        // Handle Flash write error
        Error_Handler();
    }

    // Update isModified flags
    isModified1 = (memcmp(SHARED_MEMORY->aTxBuffers1[actualNumSequences1 - 1], 
                          originalLastRow1, TX_BUFFER_SIZE1) != 0);
    isModified2 = (memcmp(SHARED_MEMORY->aTxBuffers2[actualNumSequences2 - 1], 
                          originalLastRow2, TX_BUFFER_SIZE2) != 0);
}

static void ProcessLastTwoRows(uint8_t* data, uint32_t length)
{
    if (length != (TX_BUFFER_SIZE1 + TX_BUFFER_SIZE2 + 2 * sizeof(uint32_t)))
    {
        // Error: Incorrect data size
        Error_Handler();
        return;
    }

    uint32_t duration1, duration2;
    uint32_t offset = 0;

    // Copy first row to aTxBuffers1
    memcpy(SHARED_MEMORY->aTxBuffers1[actualNumSequences1 - 1], data + offset, TX_BUFFER_SIZE1);
    offset += TX_BUFFER_SIZE1;

    // Get duration for first row
    memcpy(&duration1, data + offset, sizeof(uint32_t));
    offset += sizeof(uint32_t);

    // Copy second row to aTxBuffers2
    memcpy(SHARED_MEMORY->aTxBuffers2[actualNumSequences2 - 1], data + offset, TX_BUFFER_SIZE2);
    offset += TX_BUFFER_SIZE2;

    // Get duration for second row
    memcpy(&duration2, data + offset, sizeof(uint32_t));

    // Start the modification
    modificationStartTime = HAL_GetTick();
    isModified1 = 1;
    isModified2 = 1;

    // Set individual durations
    modificationDuration1 = duration1;
    modificationDuration2 = duration2;

    // Update originalLastRow1 and originalLastRow2
    // memcpy(originalLastRow1, SHARED_MEMORY->aTxBuffers1[actualNumSequences1 - 1], TX_BUFFER_SIZE1);
    // memcpy(originalLastRow2, SHARED_MEMORY->aTxBuffers2[actualNumSequences2 - 1], TX_BUFFER_SIZE2);
}


static void CheckAndResetModifications(void)
{
    uint32_t currentTime = HAL_GetTick();

    if (isModified1 && (currentTime - modificationStartTime >= modificationDuration1))
    {
        memcpy(SHARED_MEMORY->aTxBuffers1[actualNumSequences1 - 1], 
               originalLastRow1, TX_BUFFER_SIZE1);
        isModified1 = 0;
    }

    if (isModified2 && (currentTime - modificationStartTime >= modificationDuration2))
    {
        memcpy(SHARED_MEMORY->aTxBuffers2[actualNumSequences2 - 1], 
               originalLastRow2, TX_BUFFER_SIZE2);
        isModified2 = 0;
    }
}

static void PollCANMessages(void)
{
    static uint32_t totalChunks = 0;
    static uint32_t receivedChunks = 0;
    static uint8_t isLastTwoLines = 0;
    static uint8_t receivedData[sizeof(SharedMemory_TypeDef)];
    static uint8_t expectedSeq = 0;

    if (HAL_FDCAN_GetRxFifoFillLevel(&hfdcan, FDCAN_RX_FIFO0) > 0)
    {
        FDCAN_RxHeaderTypeDef RxHeader;
        uint8_t RxData[8];

        if (HAL_FDCAN_GetRxMessage(&hfdcan, FDCAN_RX_FIFO0, &RxHeader, RxData) == HAL_OK)
        {
            if (RxHeader.Identifier == 0x321)
            {
                if (totalChunks == 0)
                {
                    totalChunks = (RxData[0] << 24) | (RxData[1] << 16) | (RxData[2] << 8) | RxData[3];
                    isLastTwoLines = RxData[4];
                    expectedSeq = 0;
                }
                else
                {
                    uint8_t seq = RxData[0];
                    if (seq == expectedSeq)
                    {
                        memcpy(receivedData + (receivedChunks * 7), RxData + 1, 7);
                        receivedChunks++;
                        expectedSeq = (expectedSeq + 1) % 256;

                        // Send ACK
                        SendCANAcknowledgment(seq);

                        if (receivedChunks == totalChunks)
                        {
                            if (!isLastTwoLines)
                            {
                                ProcessMainData(receivedData, receivedChunks * 7);
                            }
                            else
                            {
                                ProcessLastTwoRows(receivedData, TX_BUFFER_SIZE1 + TX_BUFFER_SIZE2 + 2 * sizeof(uint32_t));
                            }
                            totalChunks = 0;
                            receivedChunks = 0;
                            isLastTwoLines = 0;
                        }
                    }
                    else
                    {
                        // Sequence mismatch, request retransmission
                        SendCANAcknowledgment(expectedSeq - 1);
                    }
                }
            }
        }
    }
}

static HAL_StatusTypeDef SendCANAcknowledgment(uint8_t seq)
{
    FDCAN_TxHeaderTypeDef TxHeader;
    uint8_t TxData[8] = {seq, 0, 0, 0, 0, 0, 0, 0};

    TxHeader.Identifier = 0x123;
    TxHeader.IdType = FDCAN_STANDARD_ID;
    TxHeader.TxFrameType = FDCAN_DATA_FRAME;
    TxHeader.DataLength = FDCAN_DLC_BYTES_8;
    TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
    TxHeader.BitRateSwitch = FDCAN_BRS_OFF;
    TxHeader.FDFormat = FDCAN_CLASSIC_CAN;
    TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
    TxHeader.MessageMarker = 0;

    return HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan, &TxHeader, TxData);
}



static uint32_t BufferCmp8b(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
{
  while(BufferLength--)
  {
    if(*pBuffer1 != *pBuffer2)
    {
      return 1;
    }
    
    pBuffer1++;
    pBuffer2++;
  }
  return 0;
}

static uint32_t PerformCANTransmission(void)
{
    FDCAN_TxHeaderTypeDef TxHeader;
    uint8_t TxData[8];
    uint32_t i;

    // Tx Header
    TxHeader.Identifier = 0x111;               // CAN ID
    TxHeader.IdType = FDCAN_STANDARD_ID;       // Standard ID
    TxHeader.TxFrameType = FDCAN_DATA_FRAME;   // Data frame
    TxHeader.DataLength = FDCAN_DLC_BYTES_8;   // DLC 8bytes
    TxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
    TxHeader.BitRateSwitch = FDCAN_BRS_OFF;
    TxHeader.FDFormat = FDCAN_CLASSIC_CAN;
    TxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
    TxHeader.MessageMarker = 0x52;             // user-defined

    // data to sent
    for (i = 0; i < 8; i++)
    {
        TxData[i] = i + 1;  // fill in some sample data
    }

    // Send messages
    if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan, &TxHeader, TxData) != HAL_OK)
    {
        return 1; // Fail to send
    }

    return 0; // Success
}

static HAL_StatusTypeDef SaveModifiedDataToFlash(void)
{
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t EraseError = 0;
  uint32_t Address = FLASH_BANK2_BASE + FLASH_SECTOR_6 * FLASH_SECTOR_SIZE;
  uint32_t *buffer_address = (uint32_t *)SHARED_MEMORY;
  uint32_t buffer_size = (sizeof(SharedMemory_TypeDef) + 31) / 32; // Round up to nearest 32 bytes
  HAL_StatusTypeDef status;
  uint32_t i;

  // Check if data size exceeds the bank size (adjust as needed)
  if (sizeof(SharedMemory_TypeDef) > (FLASH_BANK_SIZE))
  {
    return HAL_ERROR;
  }
  // Disable interrupts
  // __disable_irq();

  // Unlock the Flash to enable the flash control register access
  HAL_FLASH_Unlock();

  // Erase the user Flash area
  EraseInitStruct.TypeErase     = FLASH_TYPEERASE_SECTORS;
  EraseInitStruct.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
  EraseInitStruct.Banks         = FLASH_BANK_2;
  EraseInitStruct.Sector = FLASH_SECTOR_6;
  EraseInitStruct.NbSectors = 1;
  
  status = HAL_FLASHEx_Erase(&EraseInitStruct, &EraseError);
  if (status != HAL_OK)
  {
    Error_Handler();
  }

  // Program Flash
  i = buffer_size;
  while (i != 0)
  {
    // Program Flash Word (size 256 bits)
    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, (uint32_t)buffer_address) == HAL_OK)
    {
      // Increment for the next Flash word
      Address = Address + 32; 
      buffer_address = buffer_address + 8;
      i--;
    }
    else
    {
      // Error occurred while writing data in Flash memory
      status = HAL_ERROR;
      break;
    }
  }

  // // Lock the Flash
  // HAL_FLASH_Lock();

  // // Re-enable interrupts
  // __enable_irq();

  // Verify written data
  if (status == HAL_OK)
  {
    if (memcmp((void*)(FLASH_BANK2_BASE + FLASH_SECTOR_6 * FLASH_SECTOR_SIZE), 
               SHARED_MEMORY, 
               sizeof(SharedMemory_TypeDef)) != 0)
    {
      status = HAL_ERROR;
    }
  }

  return status;
}

static void LoadDataFromFlash(void)
{
    uint32_t *flash_data = (uint32_t *)(FLASH_BANK2_BASE + FLASH_SECTOR_6 * FLASH_SECTOR_SIZE);

    if (*flash_data == 0x00000000)  // Assuming erased flash is all 1's
    {
        // Copy entire SharedMemory_TypeDef structure from flash
        memcpy(SHARED_MEMORY, flash_data, sizeof(SharedMemory_TypeDef));
        
        // Update global variables
        actualNumSequences1 = SHARED_MEMORY->actualNumSequences1;
        actualNumSequences2 = SHARED_MEMORY->actualNumSequences2;
    }
    else
    {
        // If flash is empty, initialize with default values
        actualNumSequences1 = NUM_SEQUENCES1;  // Use the original define
        actualNumSequences2 = NUM_SEQUENCES2;  // Use the original define
        SHARED_MEMORY->actualNumSequences1 = actualNumSequences1;
        SHARED_MEMORY->actualNumSequences2 = actualNumSequences2;
        
        memcpy(SHARED_MEMORY->aTxBuffers1, aTxBuffers1, 
               actualNumSequences1 * TX_BUFFER_SIZE1);
        memcpy(SHARED_MEMORY->aTxBuffers2, aTxBuffers2, 
               actualNumSequences2 * TX_BUFFER_SIZE2);
        memcpy(SHARED_MEMORY->sequenceRepeatCounts1, sequenceRepeatCounts1, 
               actualNumSequences1 * sizeof(uint32_t));
        memcpy(SHARED_MEMORY->sequenceRepeatCounts2, sequenceRepeatCounts2, 
               actualNumSequences2 * sizeof(uint32_t));
        SHARED_MEMORY->flag = 0;
    }
    
    isModified1 = 0;
    isModified2 = 0;
}